# 05. 트랜잭션과 잠금

5장은 MySQL에서 **동시성 문제를 어떻게 해결하는지**를 다룬다.

핵심은 트랜잭션이 정합성을 책임지고, 잠금이 동시성을 제어한다는 점이다.

이 둘은 분리된 개념처럼 보이지만 실제로는 강하게 연결되어 있다.

## **5.1 트랜잭션**

### **5.1.1 MySQL에서의 트랜잭션**

트랜잭션은 하나의 논리적 작업 단위를 보장하는 기능이다.

- 트랜잭션은 여러 SQL 문장이 하나의 작업처럼 처리되도록 보장한다.
- 모든 작업이 성공하면 COMMIT으로 반영된다.
- 중간에 오류가 발생하면 ROLLBACK으로 이전 상태로 되돌린다.

트랜잭션의 목적은 **부분 업데이트를 방지하는 것**이다.

- 일부만 반영된 데이터는 정합성을 깨뜨린다.
- 특히 여러 테이블을 동시에 갱신하는 로직에서는 문제가 심각해진다.

MyISAM이나 MEMORY 엔진은 트랜잭션을 지원하지 않는다.

- 오류 발생 시 이미 수행된 작업을 되돌릴 수 없다.
- 개발자가 직접 보정 로직을 작성해야 한다.
- 로직이 복잡해질수록 실패 케이스를 모두 처리하기 어렵다.

InnoDB는 트랜잭션을 통해 이 문제를 구조적으로 해결한다.

- 실패 시 자동으로 이전 상태로 복구된다.
- 애플리케이션 로직이 단순해진다.

### **5.1.2 트랜잭션 사용 시 주의사항**

트랜잭션은 최소 범위로 사용하는 것이 중요하다.

- 트랜잭션이 길어질수록 잠금 유지 시간이 늘어난다. (레코드락)
- 잠금 대기가 발생하면 전체 처리량이 급격히 떨어진다.

다음 작업들은 트랜잭션에서 분리하는 것이 바람직하다.

- 네트워크 통신
- 파일 업로드나 외부 시스템 연동
- 사용자 입력 대기

트랜잭션은 **DB 작업만 포함하도록 설계해야 한다.**

## **5.2 MySQL 엔진의 잠금**

MySQL의 잠금은 MySQL **엔진 레벨 잠금과 스토리지 엔진 레벨 잠금**으로 나뉜다.

- MySQL 엔진 잠금은 모든 스토리지 엔진에 영향을 준다.
- 스토리지 엔진 잠금은 해당 엔진 내부에서만 동작한다.

### **5.2.1 글로벌 락**

글로벌 락은 MySQL 서버 전체에 영향을 미친다.

- FLUSH TABLES WITH READ LOCK 명령으로 획득한다.
- 모든 테이블에 대한 쓰기 작업이 차단된다.

주 용도는 백업이다. (mysqldump)

- MyISAM이나 MEMORY 테이블이 포함된 백업에 필요하다.
- 전체 서버가 멈추기 때문에 운영 중 사용은 매우 위험하다.

MySQL 8에서는 백업 전용 락이 추가되었다.

- LOCK INSTANCE FOR BACKUP 명령을 사용한다.
- 기존 글로벌 락보다 영향 범위가 제한적이다.

### **5.2.2 테이블 락**

테이블 락은 테이블 단위로 적용된다.

- LOCK TABLES ... READ | WRITE 명령으로 명시적 획득이 가능하다.
- 묵시적 테이블 락은 MyISAM 이나 MEMORY 테이블에 데이터를 변경하는 쿼리를 실행하면 발생한다.

InnoDB에서도 테이블 락은 존재한다.

- 하지만 DML에서는 대부분 레코드 락을 사용한다.
- 테이블 락은 주로 스키마를 변경하는 DDL에서만 의미를 가진다.

### **5.2.3 네임드 락**

네임드 락은 문자열 단위로 동작하는 사용자 정의 락이다.

- GET_LOCK, RELEASE_LOCK 함수로 제어한다.
- 테이블이나 레코드와 무관하다.

다음 상황에서 유용하다.

- 여러 서버 인스턴스 간 작업 순서를 제어할 때
- 배치 작업이나 동기화 작업에서 사용된다.

### **5.2.4 메타데이터 락**

메타데이터 락은 테이블 구조 보호를 위한 락이다.

- SELECT, INSERT, UPDATE 같은 DML 실행 시에도 자동으로 공유 메타데이터 락을 획득한다.
- DDL 실행 시에는 배타적 메타데이터 락을 획득해 다른 세션의 접근을 차단한다.

RENAME TABLE은 대표적인 메타데이터 락 사용 예다.

- 여러 테이블 이름을 한 번에 변경할 수 있다.
- 서비스 중단 없이 테이블 교체가 가능하다.

## **5.3 InnoDB 스토리지 엔진의 잠금**

InnoDB의 잠금은 **레코드 기반**이다.

- 동시성 처리가 매우 세밀하다.
- 대신 구조가 복잡하다.

<img width="577" height="430" alt="image" src="https://github.com/user-attachments/assets/83cadd7b-3368-4327-9801-6b812b5794f1" />

### **5.3.1 레코드 락**

InnoDB 스토리지 엔진의 레코드 락은 레코드 자체가 아니라 인덱스 레코드를 잠근다.

- 실제 데이터 레코드가 아니라 인덱스 레코드를 잠근다.
- 명시적인 인덱스가 없는 테이블이더라도 자동 생성된 클러스터 인덱스를 이용해 잠근다.
- 인덱스를 사용할 수 없는 조건에서는 테이블을 풀 스캔하면서 클러스터 인덱스의 **모든 레코드에 레코드 락이 걸릴 수 있다.**

### **5.3.2 갭 락**

갭 락은 인덱스 레코드와 레코드 사이의 구간을 잠그는 락이다.

- 갭 락은 해당 구간에 새로운 레코드의 INSERT를 방지한다.
- 실제 레코드를 잠그는 것이 아니라 인덱스 상의 빈 구간을 보호한다.
- 갭 락은 단독으로 사용되기보다는 넥스트 키 락의 일부로 동작하는 경우가 많다.
- 일반 SELECT에서는 사용되지 않으며(MVCC 기반이기 때문) SELECT FOR UPDATE, UPDATE, DELETE 같은 현재 읽기에서 넥스트 키 락의 일부로 동작해 팬텀 리드를 방지한다.

### **5.3.3 넥스트 키 락**

넥스트 키 락은 하나의 인덱스 레코드와 그 레코드 뒤쪽의 갭을 함께 잠그는 락이다.

- 이 잠금은 기존 레코드의 변경과 새로운 레코드의 INSERT를 동시에 차단한다.
- InnoDB는 REPEATABLE READ 격리 수준에서 현재 읽기 시 넥스트 키 락을 기본으로 사용한다.

```sql
SELECT * FROM orders
WHERE amount BETWEEN 100 AND 200
FOR UPDATE;
```

### **5.3.4 자동 증가 락**

AUTO_INCREMENT 컬럼 보호를 위한 락이다.

- 동시에 여러 INSERT가 발생할 때 값 충돌을 방지한다.
- 설정에 따라 동작 방식이 달라진다.

MySQL 8에서는 기본 동작이 개선되었다.

- 동시 INSERT 성능이 크게 향상되었다.

### **5.3.5 인덱스와 잠금의 관계**

InnoDB 잠금의 범위는 인덱스 설계에 따라 달라진다.

- 적절한 인덱스가 있으면 필요한 레코드만 잠근다.
- 인덱스가 없으면 대량 레코드 잠금이 발생한다.

이는 성능 문제의 가장 흔한 원인이다.

### **5.3.6 잠금 확인과 해제**

MySQL 8에서는 잠금 정보를 쉽게 확인할 수 있다.

- performance_schema.data_locks.
- performance_schema.data_lock_waits.

대기 중인 트랜잭션과 잠금 관계를 직접 확인할 수 있다.

- 필요하면 KILL로 트랜잭션을 강제 종료할 수 있다.

## **5.4 MySQL의 격리 수준**

격리 수준은 트랜잭션 간 데이터 가시성을 정의한다.

MySQL은 네 가지 격리 수준을 지원한다.

- READ UNCOMMITTED
- READ COMMITTED
- REPEATABLE READ
- SERIALIZABLE

<img width="746" height="235" alt="image" src="https://github.com/user-attachments/assets/d821fc17-97ee-4ffd-a1ec-560bf3e881e9" />

### **5.4.1 READ UNCOMMITTED**

- 커밋되지 않은 데이터를 읽을 수 있다.
- 더티 리드가 발생한다.
- 실무에서는 거의 사용하지 않는다.

<img width="507" height="514" alt="image" src="https://github.com/user-attachments/assets/64b511c2-5b76-412a-9779-46ffb03d50c2" />

### **5.4.2 READ COMMITTED**

- 커밋된 데이터만 읽을 수 있다.
- 더티 리드는 발생하지 않는다.
- NON REPEATABLE READ는 발생한다.
- Oracle의 기본 격리 수준이다.

<img width="508" height="487" alt="image" src="https://github.com/user-attachments/assets/636dac43-029f-488d-8862-d178f8c8e3ae" />

<img width="524" height="489" alt="image" src="https://github.com/user-attachments/assets/a4a2dcb6-a099-4bfc-9b0b-7d1cf235bb55" />

### **5.4.3 REPEATABLE READ**

- MySQL InnoDB의 기본 격리 수준이다.
- 동일 트랜잭션 내에서 항상 같은 결과를 보장한다.
- MVCC를 통해 구현된다.
- InnoDB는 일반 SELECT에서는 언두 로그 기반 MVCC로 스냅샷을 고정해 팬텀 리드를 보이지 않게 하고, SELECT FOR UPDATE 같은 현재 읽기에서는 넥스트 키 락을 사용해 팬텀 리드를 물리적으로 방지한다.

<img width="573" height="623" alt="image" src="https://github.com/user-attachments/assets/beb4801d-2da6-4dec-acbc-8931152dec9a" />

<img width="564" height="564" alt="image" src="https://github.com/user-attachments/assets/d5ba5f0f-e92e-40d8-96b7-a5d59347a69b" />

### **5.4.4 SERIALIZABLE**

가장 엄격한 격리 수준이다.

- 모든 SELECT도 잠금을 획득한다.
- 동시성이 크게 떨어진다.

InnoDB에서는 거의 사용할 필요가 없다.

## **5장 전체 정리**

- 트랜잭션은 데이터 정합성을 책임진다.
- 잠금은 동시성 제어를 책임진다.
- InnoDB는 레코드 기반 잠금으로 높은 동시성을 제공한다.
- 인덱스 설계는 잠금 범위를 결정한다.
- MySQL 8에서는 잠금 모니터링이 훨씬 쉬워졌다.
- 기본 격리 수준인 REPEATABLE READ는 대부분의 서비스에 충분하다.
