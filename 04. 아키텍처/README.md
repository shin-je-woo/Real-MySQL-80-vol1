# 04. 아키텍처

## 4.1 MySQL 엔진 아키텍처

MySQL 서버는 여러 구성 요소가 역할을 나눠 협력하는 구조다.

SQL이 들어온 뒤 스토리지 엔진에 전달되기까지 MySQL 엔진 내부에서 어떤 처리가 일어나는지 이해하는 것이 목적이다.

### 4.1.1 MySQL 서버의 전체 구조

<img width="772" height="812" alt="image" src="https://github.com/user-attachments/assets/e6e611c7-600c-4d76-a65f-0da879c69e41" />

- MySQL 서버는 두 계층으로 나뉜다.
    - SQL을 이해하고 실행 흐름을 제어하는 계층
    - 실제 데이터를 저장하고 읽는 계층
- 클라이언트가 SQL을 보내면 서버 내부에서 다음 순서로 처리된다.
    - 네트워크 레이어가 요청을 수신한다.
    - 인증과 권한 검사를 수행한다.
    - SQL 문자열을 내부 표현으로 변환한다.
    - 실행 계획을 만든다.
    - 실행 계획에 따라 스토리지 엔진 API를 호출한다.
- 스토리지 엔진은 SQL 문장 자체를 알지 못한다.
    - 조건에 맞는 레코드를 읽는다.
    - 레코드를 갱신한다.
        
        같은 저수준 요청만 처리한다.
        
- 따라서 MySQL 엔진과 스토리지 엔진의 책임 경계를 구분하는 것이 중요하다.

### 4.1.2 MySQL 스레딩 구조

<img width="900" height="608" alt="image" src="https://github.com/user-attachments/assets/0db4c79e-0853-4788-9705-23bc57697a28" />

- MySQL은 연결 단위 스레드 모델을 사용한다.
    - 클라이언트가 접속하면 스레드를 하나 할당한다.
    - 연결이 종료될 때까지 해당 스레드가 요청을 처리한다.
- 스레드가 담당하는 작업 범위가 넓다.
    - 네트워크 IO를 처리한다.
    - 파싱과 실행 단계 호출을 수행한다.
    - 트랜잭션 시작과 종료를 담당한다.
    - 결과를 클라이언트로 전송한다.
- 연결 수가 늘면 스레드 수가 늘어날 수 있다.
    - 스레드 생성과 제거 비용을 줄이기 위해 스레드 캐시를 사용한다.
    - 동시 접속이 폭증하면 스레드 수 자체가 병목이 될 수 있다.

### 4.1.3 MySQL 메모리 구조

<img width="650" height="448" alt="image" src="https://github.com/user-attachments/assets/7340b1cf-2a16-4d6c-9fc5-c273618eaf81" />

- 메모리는 글로벌 메모리와 로컬 메모리로 나뉜다.
- 글로벌 메모리의 특징은 다음과 같다.
    - 서버 전체에서 공유된다.
    - 예로 InnoDB 버퍼 풀, 로그 버퍼, 테이블 캐시가 있다.
    - 서버 시작 시 크기가 결정된다.
- 로컬 메모리의 특징은 다음과 같다.
    - 스레드가 쿼리 실행 중 필요할 때 할당한다.
    - 정렬, 조인, 임시 처리 같은 작업에 쓰인다.
    - 동시 실행 쿼리 수에 비례해 사용량이 늘어날 수 있다.
- 운영에서 자주 생기는 문제 패턴은 다음과 같다.
    - 버퍼 풀은 충분하다고 느껴진다.
    - 특정 시점에 트래픽이 몰린다.
    - 정렬이나 조인이 많은 쿼리가 동시에 실행된다.
    - 로컬 메모리가 급증하면서 전체 메모리가 부족해진다.
- 따라서 MySQL 메모리 이슈는 총량보다 동시 실행 쿼리 수와 강하게 연결된다.

### 4.1.4 플러그인 구조

- MySQL의 많은 기능은 플러그인 형태로 구현되어 있다.
- MySQL 엔진은 정해진 인터페이스를 통해 외부 모듈을 호출하는 구조다.
- 스토리지 엔진도 이 인터페이스를 구현한 플러그인 중 하나다.
- 이 구조가 주는 의미는 다음과 같다.
    - MySQL 엔진은 데이터 저장 방식을 추상화한다.
    - InnoDB와 MyISAM 같은 엔진이 동일한 호출 규약으로 동작한다.
    - SQL 처리 로직은 엔진 내부에서 일관되게 유지된다.
- 반대로 이 분리 구조 때문에 엔진 내부 최적화가 스토리지 엔진의 세부 구현을 전부 활용하지 못할 수도 있다.

### 4.1.5 SQL 실행의 내부 흐름

<img width="772" height="574" alt="image" src="https://github.com/user-attachments/assets/36a36607-f9ec-4f2c-8fa6-219b3156502c" />

- MySQL 엔진 내부에서 SQL은 여러 단계를 거쳐 처리된다.
    - 파서는 SQL을 내부 트리 구조로 변환한다.
    - 옵티마이저는 이 트리를 기반으로 실행 경로를 계산한다.
    - 실행기는 계획에 따라 스토리지 엔진 API를 호출한다.
- 옵티마이저는 실제 데이터를 직접 보지 않고 판단한다.
    - 통계 정보에 의존한다.
    - 인덱스 구조에 의존한다.
    - 비용 모델에 의존한다.
- 통계가 오래되거나 데이터 분포가 바뀌면 실행 계획이 비효율적일 수 있다.

### 4.1.6 트랜잭션 지원 메타데이터

- MySQL 8.0 이전에는 메타데이터 변경이 항상 트랜잭션 안전하지 않았다.
- DDL 도중 장애가 발생하면 메타데이터와 실제 파일 상태가 어긋날 수 있었다.
- MySQL 8.0에서는 메타데이터를 InnoDB 테이블로 관리한다.
    - 메타데이터 변경도 트랜잭션으로 처리한다.
    - 비정상 종료 시에도 복구 대상이 된다.
- 이로 인해 DDL 작업 안정성과 서버 일관성이 향상된다.

## 4.2 InnoDB 스토리지 엔진 아키텍처

InnoDB는 MySQL 8의 기본 스토리지 엔진이다.

데이터 저장뿐 아니라 트랜잭션, 동시성 제어, 장애 복구까지 책임진다.

InnoDB의 기능은 메모리 구조, 로그 구조, 디스크 구조가 맞물려 동작하면서 만들어진다.

<img width="812" height="770" alt="image" src="https://github.com/user-attachments/assets/44ca65f9-8025-4cc4-b9f8-398983be4bc3" />

### 4.2.1 InnoDB 스토리지 엔진의 특징

- 트랜잭션을 지원한다.
- 레코드 단위 잠금을 지원한다.
- MVCC 기반 잠금 없는 일관된 읽기를 지원한다.
- 외래 키를 지원한다.
- 장애 발생 시 자동 복구를 지원한다.

### 4.2.2 InnoDB 아키텍처 개요

- InnoDB 내부는 크게 다음 영역으로 나뉜다.
    - 메모리 영역
    - 로그 관련 영역
    - 디스크 데이터 영역
- 성능의 중심은 메모리 영역이다.
- 안정성과 복구의 중심은 로그 영역이다.
- InnoDB는 변경을 즉시 디스크에 쓰지 않고 메모리에 버퍼링 해두었다가 지연 처리하는 구조다.

### 4.2.3 버퍼 풀(Buffer Pool)

- 버퍼 풀은 InnoDB에서 가장 중요한 구성 요소다.
- 버퍼 풀은 데이터 페이지와 인덱스 페이지를 메모리에 캐시한다.
- 버퍼 풀은 변경된 페이지를 임시로 보관하는 역할도 한다.
- 읽기 시 동작은 다음과 같다.
    - 먼저 버퍼 풀에서 페이지를 찾는다.
    - 없으면 디스크에서 읽어 버퍼 풀에 적재한다.
- 쓰기 시 동작은 다음과 같다.
    - 변경은 먼저 버퍼 풀에 반영된다.
    - 디스크에는 즉시 기록되지 않는다.
- 이 구조 덕분에 InnoDB는 랜덤 디스크 IO를 최소화하고 높은 처리량을 유지할 수 있다.

### 4.2.4 페이지 단위 처리

- InnoDB는 레코드 단위가 아니라 **페이지 단위**로 데이터를 관리한다.
- 기본 페이지 크기는 16KB다.
- 디스크 IO와 버퍼 풀 관리가 모두 페이지 단위로 이루어진다.
- 한 레코드만 필요해도 해당 레코드가 포함된 페이지 전체를 읽는다.
- 페이지 단위 처리는 순차 IO에 유리하지만 불필요한 데이터까지 읽는 비용이 생길 수 있다.

### 4.2.5 클러스터링 인덱스 구조

- InnoDB 테이블은 프라이머리 키 기준으로 클러스터링되어 저장된다.
- 테이블 자체가 프라이머리 키 인덱스다.
- 데이터는 프라이머리 키 순서로 저장된다.
- 세컨더리 인덱스는 인덱스 키와 프라이머리 키 값을 함께 저장한다.
- 세컨더리 인덱스로 레코드를 읽으면 두 단계가 필요하다.
    - 세컨더리 인덱스를 탐색한다.
    - 프라이머리 키 인덱스를 다시 탐색한다.
- 따라서 프라이머리 키 설계는 성능에 큰 영향을 준다.

### 4.2.6 InnoDB와 MySQL 엔진의 역할 분담

- InnoDB는 SQL 의미를 이해하지 않는다.
- WHERE, JOIN, 정렬 같은 판단은 MySQL 엔진이 수행한다.
- InnoDB는 저수준 요청을 처리한다.
    - 인덱스 기반 레코드 읽기 요청을 처리한다.
    - 레코드 갱신 요청을 처리한다.
    - 트랜잭션 커밋과 롤백 요청을 처리한다.

### 4.2.7 InnoDB의 변경 처리 전체 흐름

- InnoDB에서 데이터 변경은 즉시 디스크에 기록되지 않는다.
- 흐름은 다음과 같다.
    - 변경 내용은 버퍼 풀 페이지에 반영된다.
    - 버퍼 풀 페이지는 더티 페이지가 된다.
    - 언두 로그에 변경 전 데이터가 기록된다.
    - 리두 로그에 변경 내역이 기록된다.
    - 커밋 시 리두 로그가 디스크에 기록된다.
    - 더티 페이지는 이후 백그라운드 스레드에 의해 디스크로 플러시된다.
- 이 구조는 데이터와 로그의 기록 시점을 분리해 커밋 지연을 줄인다.

### 4.2.8 Dirty Page와 플러시 동작

- 더티 페이지는 메모리에는 최신 상태가 반영되어 있지만 디스크에는 반영되지 않은 페이지다.
- 더티 페이지는 언젠가 디스크로 기록되어야 한다.
- 이 작업을 플러시라고 한다.
- 플러시는 즉시 수행되지 않을 수 있다.
    - 디스크 IO 비용이 크다.
    - 랜덤 IO를 최소화해야 한다.
    - 사용자 쿼리 지연을 줄여야 한다.
- InnoDB는 더티 페이지 비율, 리두 로그 공간, 시스템 부하에 따라 플러시 강도를 조절한다.

### 4.2.9 Double Write Buffer

- InnoDB는 디스크에 페이지를 기록할 때 부분 쓰기 문제를 고려한다.
- 부분 쓰기는 페이지 일부만 기록된 상태에서 장애가 발생하는 상황이다.
- InnoDB는 Double Write Buffer로 이를 완화한다.
    - 먼저 Double Write 영역에 순차 기록한다.
    - 그 다음 데이터 파일에 기록한다.
- 장애 시 Double Write 영역을 기준으로 복구할 수 있다.
- 이 구조는 성능보다 데이터 무결성을 우선한 설계다.

### 4.2.10 Undo Log

- 언두 로그는 롤백과 MVCC를 위해 필요하다.
- 데이터 변경 시 변경 전 값이 언두 로그에 기록된다.
- 롤백 시 언두 로그를 이용해 변경 전 상태로 되돌린다.
- 다른 트랜잭션은 언두 로그를 이용해 자신이 볼 수 있는 시점의 데이터를 재구성한다.
- 긴 트랜잭션은 언두 로그를 오래 유지하게 되므로 주의해야 한다.
- 언두 로그가 쌓이면 purge 지연과 성능 저하로 이어질 수 있다.

### 4.2.11 Redo Log와 커밋 처리

- 리두 로그는 내구성을 책임진다.
- InnoDB에서 커밋은 데이터 페이지 디스크 기록을 의미하지 않는다.
- InnoDB에서 커밋은 리두 로그 디스크 기록이 완료되었음을 의미한다.
- 커밋 흐름은 다음과 같다.
    - 트랜잭션이 커밋을 요청한다.
    - 리두 로그가 로그 파일에 기록된다.
    - 디스크 동기화가 완료되면 커밋이 완료된다.
- 데이터 페이지 플러시는 이후에 수행될 수 있다.
- 이 구조 덕분에 커밋은 빠르게 완료되고, 장애 발생 시에도 Redo Log를 기반으로 복구할 수 있다.

### 4.2.12 장애 복구 흐름

- MySQL 서버가 비정상 종료 후 재시작 시 InnoDB는 자동 복구를 수행한다.
- 리두 로그를 읽어 커밋된 변경을 재적용한다.
- 커밋되지 않은 변경은 언두 로그로 롤백한다.
- 이 과정으로 데이터 파일과 로그 파일의 상태가 일관되게 맞춰진다.

### 4.2.13 버퍼 풀 내부 구조

- 버퍼 풀은 여러 리스트로 관리된다.
    - LRU 리스트
    - Free 리스트
    - Flush 리스트
- LRU 리스트는 사용 중인 페이지를 관리한다.
    - 최근 접근된 페이지가 앞쪽에 위치한다.
    - 오래 사용되지 않은 페이지가 뒤쪽에 위치한다.
    - 대량 스캔이 캐시를 오염시키지 않도록 단순 LRU보다 정교한 정책을 사용한다.
- Free 리스트는 빈 페이지를 관리한다.
    - 새 페이지를 읽어올 때 사용한다.
    - 부족하면 LRU에서 페이지를 회수해 보충한다.
- Flush 리스트는 더티 페이지를 관리한다.
    - 디스크 기록 제어의 기준이 된다.

### 4.2.14 플러시가 중요한 이유

- 플러시가 지연되면 더티 페이지가 쌓인다.
- 리두 로그 공간이 줄어든다.
- 체크포인트가 밀릴 수 있다.
- 장애 발생 시 복구 시간이 길어질 수 있다.
- InnoDB는 부하와 로그 사용량을 보면서 미리 조금씩 플러시하려 한다.

### 4.2.15 Change Buffer

- Change Buffer는 보조 인덱스 변경을 지연 처리한다.
- 보조 인덱스 페이지가 디스크에 있으면 매번 읽어 수정할 때 랜덤 IO가 커질 수 있다.
- InnoDB는 보조 인덱스 변경 내용을 Change Buffer에 모았다가 나중에 병합한다.
    - 인덱스 페이지가 버퍼 풀에 올라올 때 병합한다.
    - 백그라운드 병합이 수행될 때 병합한다.
- 쓰기 위주 워크로드에서 효과가 클 수 있다.
- 읽기 위주 환경에서는 효과가 제한적일 수 있다.

### 4.2.16 InnoDB 구조 요약

- InnoDB는 변경을 메모리에서 처리한다.
- 내구성은 로그로 보장한다.
- 디스크 기록은 나중으로 미룬다.
- 이로 인해 커밋이 빠르고 장애 복구가 가능하다.
- 메모리, 로그, 플러시 타이밍의 균형이 깨지면 성능 문제가 커질 수 있다.

### 4.2.17 Adaptive Hash Index

- Adaptive Hash Index는 반복되는 탐색 패턴을 감지해 InnoDB가 자동으로 생성하는 인메모리 해시 구조다.
- B Tree 탐색 경로가 반복될 때 해시로 빠르게 페이지에 접근한다.
- 동등 조건 반복 조회에서 성능 개선이 클 수 있다.
- But, 메모리 사용이 늘어나고 내부 경합이 생길 수 있다.
- 쓰기와 DDL이 많은 환경에서는 병목이 될 수 있다.

### 4.2.18 InnoDB 내부 구조와 성능의 관계

- 변경은 버퍼 풀에서 처리된다.
- 언두 로그는 롤백과 MVCC를 지원한다.
- 리두 로그는 커밋 내구성과 복구를 보장한다.
- 더티 페이지는 나중에 플러시된다.
- 버퍼 풀이 작으면 디스크 IO가 늘어날 수 있다.
- 언두 로그가 쌓이면 MVCC 비용이 늘어날 수 있다.
- 리두 로그 공간이 부족하면 플러시 압박이 커질 수 있다.
- 플러시가 밀리면 지연과 복구 시간이 늘어날 수 있다.

### 4.2.19 InnoDB가 기본 엔진인 이유

- 트랜잭션을 보장한다.
- 장애 복구가 가능하다.
- 동시성 처리에 강하다.
- 이 특성은 버퍼 풀, 언두 로그, 리두 로그, 플러시 메커니즘이 결합된 결과다.
- MyISAM은 이 요구 사항에 취약하다.

### 4.2.20 InnoDB 아키텍처를 보는 관점 정리

- 커밋은 데이터 파일 쓰기가 아니라 리두 로그 확정이다.
- 디스크 IO는 대부분 지연된다.
- 성능의 중심은 메모리와 로그다.
- 장애 복구는 로그를 기준으로 이루어진다.

## 4.3 MyISAM 스토리지 엔진 아키텍처

MyISAM은 InnoDB 이전의 기본 스토리지 엔진이며, MySQL 8에서는 레거시 엔진에 가깝다.

<img width="614" height="756" alt="image" src="https://github.com/user-attachments/assets/eb0ee88e-e390-44d4-bda3-ba9fc9014a3b" />

### 4.3.1 MyISAM의 기본 구조

- 데이터 파일과 인덱스 파일이 분리되어 있다.
- 트랜잭션을 지원하지 않는다.
- MVCC가 없다.
- 복구 메커니즘이 제한적이다.
- 구현이 단순하고 읽기가 빠를 수 있다.
- 동시성과 안정성이 중요한 환경에서는 한계가 크다.

### 4.3.2 잠금 방식

- 테이블 단위 잠금을 사용한다.
- 쓰기 작업이 수행되면 테이블 전체가 잠긴다.
- 동시에 다른 쓰기 작업이 진행될 수 없다.
- 읽기와 쓰기가 쉽게 충돌한다.
- 현대 서비스 환경의 동시성 요구와 맞지 않는다.

### 4.3.3 장애 복구와 안정성

- 트랜잭션 로그가 없다.
- 비정상 종료 시 마지막 변경 상태를 보장하기 어렵다.
- 테이블 손상이 발생할 수 있다.
- 복구는 테이블 검사와 수동 복구에 의존한다.
- 무결성이 중요한 시스템에는 적합하지 않다.

### 4.3.4 현재 MyISAM의 위치

- MySQL 8 기준 기본 엔진이 아니다.
- 신규 설계에 권장되지 않는다.
- 읽기 전용 또는 특수 목적에서 제한적으로 사용된다.
- InnoDB가 기본 선택이 된 이유를 이해하는 비교 대상으로 보면 된다.

## 4.4 MySQL 로그 파일

MySQL 서버는 여러 로그를 통해 서버 상태, 오류, 성능 문제를 기록한다.

### 4.4.1 에러 로그

- 서버 시작과 종료를 기록한다.
- 비정상 종료를 기록한다.
- 복구 과정 메시지를 기록한다.
- 설정 오류와 내부 경고를 기록한다.
- 장애가 발생했을 때 가장 먼저 확인해야 한다.

### 4.4.2 제너럴 로그

- 서버로 들어오는 모든 SQL을 기록한다.
- 어떤 클라이언트가 어떤 SQL을 언제 실행했는지 확인할 수 있다.
- 기록량이 크고 성능 부담이 크다.
- 운영에서 상시 활성화는 권장되지 않는다.

### 4.4.3 슬로우 쿼리 로그

- 기준 시간보다 오래 걸린 쿼리를 기록한다.
- 실행 시간뿐 아니라 잠금 대기 시간도 함께 볼 수 있다.
- 검사한 행 수와 반환한 행 수 같은 정보도 남는다.
- 튜닝에서는 누적 부하가 큰 쿼리를 우선적으로 분석하는 것이 효과적이다.

## 4장 전체 정리

- MySQL 엔진은 SQL을 해석하고 실행 흐름을 제어한다.
- 스토리지 엔진은 실제 데이터 처리와 트랜잭션을 담당한다.
- InnoDB는 메모리 기반 처리와 로그 기반 복구, 지연된 디스크 쓰기를 결합한다.
- 버퍼 풀, 언두 로그, 리두 로그는 하나의 흐름으로 동작한다.
- MyISAM은 트랜잭션과 동시성, 복구 측면에서 한계가 크다.
- 로그 파일은 장애 대응과 성능 분석의 출발점이다.
