# 09. 옵티마이저와 힌트

이 장에서는 MySQL 서버가 **동일한 결과를 내기 위해 어떤 실행 경로를 선택하는지**,

그리고 그 선택이 **성능에 어떤 영향을 미치는지**를 다룬다.

핵심은 옵티마이저가 **어떤 기준으로 실행 계획을 선택하는지와** 정렬, GROUP BY, DISTINCT 같은 연산이 **왜 느려질 수 있는지**를 이해하는 것이다.

## **9.1 개요**

- SQL은 선언형 언어
- 사용자는 무엇을 원하는지만 작성
- 어떻게 처리할지는 MySQL 옵티마이저가 결정
- 옵티마이저의 역할은 여러 실행 방법 중 **비용이 가장 낮다고 판단되는 실행 계획 선택**

## **9.1.1 쿼리 실행 절차**

MySQL 쿼리는 크게 세 단계로 처리된다.

1. **SQL 파싱**
    - SQL 문법 검사
    - SQL 파스 트리 생성
2. **최적화**
    - 접근 테이블 결정
    - 인덱스 선택
    - 조인 순서 결정
    - 정렬 및 그룹 처리 방법 결정
3. **실행**
    - 스토리지 엔진으로부터 레코드 읽기
    - 정렬, 조인, 그룹핑 수행
    - 결과 반환

첫 번째와 두 번째 단계는 주로 **MySQL 엔진**,

세 번째 단계는 **MySQL 엔진과 스토리지 엔진이 함께 수행**한다.

## **9.1.2 옵티마이저의 종류**

### **규칙 기반 옵티마이저(RBO)**

- 사전에 정의된 규칙 기반
- 데이터 분포, 통계 정보 거의 사용하지 않음
- 항상 동일한 실행 계획 생성
- 현재는 거의 사용되지 않음

### **비용 기반 옵티마이저(CBO)**

- 테이블 레코드 수
- 인덱스 카디널리티
- 통계 정보
- 예상 I/O 비용

을 기반으로 실행 계획을 선택한다.

MySQL 8.0은 **비용 기반 옵티마이저**를 사용한다.

## **9.2 기본 데이터 처리**

이 절에서는 **정렬, 스캔, 그룹화** 같은 기본 연산이 어떻게 처리되는지를 설명한다.

## **9.2.1 풀 테이블 스캔과 풀 인덱스 스캔**

### **풀 테이블 스캔**

- 테이블 처음부터 끝까지 모두 읽음
- 옵티마이저가 다음 경우 선택
    - 테이블의 레코드 건수가 너무 적은 경우
    - 적절한 인덱스가 없는 경우
    - 인덱스를 사용해도 이득이 없는 경우

InnoDB에서는 **리드 어헤드(Read Ahead)** 가 동작한다.

- 연속 페이지 읽기 감지
- 백그라운드 스레드가 미리 페이지를 읽어 버퍼 풀에 적재

### **풀 인덱스 스캔**

- 테이블이 아니라 인덱스를 처음부터 끝까지 스캔
- 테이블 스캔보다 I/O 비용이 적을 수 있음
- 다음 경우 선택
    - 필요한 컬럼이 인덱스에 모두 포함된 경우
    - 테이블보다 인덱스가 훨씬 작은 경우

## **9.2.2 병렬 처리**

MySQL 8.0부터 **하나의 쿼리를 여러 스레드로 병렬 처리 가능**

- innodb_parallel_read_threads 변수 사용
- 풀 테이블 스캔 또는 풀 인덱스 스캔 시 적용
- WHERE 조건이 없는 COUNT(*) 같은 쿼리에 효과적
- 병렬 처리용 스레드 개수가 CPU 코어 수를 초과하면 오히려 성능이 저하될 수 있다.

## **9.2.3 ORDER BY 처리**

ORDER BY는 반드시 정렬 비용을 수반하지는 않는다.

정렬은 크게 2가지 방식으로 처리된다.

1. 인덱스를 이용한 정렬
2. Filesort를 이용한 정렬

<img width="1020" height="384" alt="image" src="https://github.com/user-attachments/assets/53da1dc9-1491-48fb-af0a-440e0111805a" />

### **9.2.3.1 인덱스를 이용한 정렬**

정렬은 크게 2가지로 처리된다.

- 인덱스를 이용한 정렬
    
    인덱스 자체가 정렬되어 있으므로 별도 정렬 작업이 없다.
    
- Filesort
    
    인덱스로 정렬이 불가능할 때 MySQL이 별도의 정렬 단계를 수행한다.
    
    실행 계획 Extra에 Using filesort로 표시된다.
    

인덱스로 정렬이 항상 가능한 것은 아니다.

- 정렬 기준이 너무 다양해 모든 인덱스를 만들 수 없다.
- GROUP BY 결과 또는 DISTINCT 같은 처리의 결과를 정렬해야 하는 경우
- UNION 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
- 랜덤하게 결과 레코드를 가져와야 하는 경우

### **9.2.3.1 소트 버퍼**

MySQL은 Filesort 수행을 위해 별도 메모리 공간을 할당한다.

- 이 메모리 공간이 소트 버퍼
- 쿼리 실행 중에만 할당되고, 실행이 끝나면 반환된다.
- 크기는 sort_buffer_size로 제어
- 소트 버퍼는 전역 공유 메모리가 아니라 세션 단위로 할당된다.
- 커넥션이 많거나 정렬 쿼리가 많으면 메모리 사용량이 급증할 수 있다.
- 무작정 크게 잡는 것이 항상 빠른 것은 아니며, OS OOM 상황을 유발할 수 있다.

### **9.2.3.2 정렬 알고리즘**

Filesort는 내부적으로 크게 2가지 방식으로 수행된다.

### **싱글 패스 정렬**

정렬 키뿐 아니라 SELECT 대상 컬럼까지 함께 소트 버퍼에 담아 정렬한다.

- 장점
    
    정렬 후 테이블을 다시 읽지 않아도 된다
    
- 단점
    
    소트 버퍼에 담아야 하는 데이터가 커져 메모리 요구량이 커진다.
    

<img width="868" height="528" alt="image" src="https://github.com/user-attachments/assets/e70734f5-7db7-49d8-b48f-11c3ff37d485" />

- 테이블에서 정렬에 필요한 컬럼과 출력 컬럼을 읽어 소트 버퍼에 적재
- 소트 버퍼에서 정렬
- 정렬된 결과를 바로 반환

### **투 패스 정렬**

소트 버퍼에는 정렬 키와 로우 식별자만 담고, 정렬 후 테이블을 다시 읽는다.

- 장점
    
    소트 버퍼 사용량이 작다.
    
- 단점
    
    정렬 후 테이블을 한 번 더 읽는다.
    

<img width="824" height="514" alt="image" src="https://github.com/user-attachments/assets/bd76f441-6f4a-473b-8a8e-a0b532e821e9" />

- 테이블에서 정렬 키와 로우 식별자를 읽어 소트 버퍼에 적재
- 소트 버퍼에서 정렬
- 정렬 결과 순서대로 테이블을 재접근해 나머지 컬럼을 읽음
- 최종 결과 반환

최신 버전에서는 보통 싱글 패스 정렬 방식을 주로 사용하지만, 다음의 경우 투 패스 정렬 방식을 사용한다.

- 레코드 크기가 max_length_for_sort_data 시스템 변수 기준을 넘는 경우
- BLOB, TEXT 타입 컬럼이 SELECT 대상에 포함되는 경우

### **9.2.3.3 정렬 처리 방법**

ORDER BY가 사용되면 MySQL은 실제 실행에서 다음 3가지 중 하나로 처리한다.

위로 갈수록 빠르고 아래로 갈수록 느리다.

### **9.2.3.3.1 인덱스를 이용한 정렬**

- ORDER BY 컬럼 순서대로 인덱스가 존재하면 추가 정렬 없이 인덱스를 순서대로 읽는다.
- Extra에 Using filesort가 표시되지 않는다.
- 조인이 있더라도, 드라이빙 테이블 인덱스 순서가 유지되는 방식일 때만 자연 정렬이 유지된다.
    
    조인 버퍼 사용 등으로 순서가 흐트러지면 깨질 수 있다.
    

```sql
mysql> SELECT *
FROM employees e, salaries s
WHERE s.emp_no = e.emp_no
AND e.emp_no BETWEEN 100002 AND 100020
ORDER BY e.emp_no;
```

<img width="788" height="384" alt="image" src="https://github.com/user-attachments/assets/283c8361-d36d-4668-81bb-9a4e9ade9697" />

### **9.2.3.3.2 조인의 드라이빙 테이블만 정렬**

조인을 수행하기 전에 드라이빙 테이블에서 정렬을 먼저 만들고, 그 정렬된 결과 순서대로 조인을 진행한다.

- 조건
    
    ORDER BY 컬럼이 드라이빙 테이블 컬럼만 포함되어야 한다.
    
- 조인 결과 전체를 정렬하는 것보다 유리할 수 있다.
- 그러나 인덱스 정렬만큼 비용이 저렴하지는 않다.

```sql
mysql> SELECT *
FROM employees e, salaries s
WHERE s.emp_no = e.emp_no
AND e.emp_no BETWEEN 100002 AND 100010
ORDER BY e.last_name;
```

<img width="686" height="494" alt="image" src="https://github.com/user-attachments/assets/5402bd83-3156-4974-9d97-bd4aef6ea75a" />

### **9.2.3.3.3 임시 테이블을 이용한 정렬**

조인 결과를 먼저 만들고 그 결과를 임시 테이블에 담은 다음 정렬한다.

- 조인 결과가 커질수록 가장 비용이 큰 방식
- Extra에 보통 다음이 표시된다.
    
    Using temporary; Using filesort
    

```sql
mysql> SELECT *
FROM employees e, salaries s
WHERE s.emp_no = e.emp_no
AND e.emp_no BETWEEN 100002 AND 100010
ORDER BY s.salary;
```

<img width="658" height="708" alt="image" src="https://github.com/user-attachments/assets/7c323379-d9d8-4822-bfe0-60f30b0ad033" />

### **9.2.3.4 정렬 처리 방법의 성능 비교**

정렬 성능 비교를 할 때 단순 속도보다 **클라이언트가 언제부터 결과를 받는지**를 중요하게 본다.

이를 위해 처리 방식을 다음 2가지로 구분한다.

### **9.2.3.4.1 스트리밍 방식**

- 조건에 맞는 레코드를 찾는 즉시 클라이언트로 전송
- 서버가 모든 결과를 모을 필요가 없음
- OLTP에서는 첫 응답이 빨라 체감 성능이 좋다.
- LIMIT이 있으면 특히 유리하다.

### **9.2.3.4.2 버퍼링 방식**

- 정렬, 그룹핑처럼 결과를 모아야 하는 작업은 버퍼링이 필요.
- 서버가 모든 결과를 모은 후 처리하므로 첫 응답이 늦다.
- LIMIT이 있어도, 정렬을 위해서는 후보를 많이 모아야 해서 효과가 제한될 수 있다.

참고 포인트

- 서버가 스트리밍으로 보내도 클라이언트 드라이버가 내부 버퍼링을 하면 체감은 달라질 수 있다.
    
    예를들어, JDBC 드라이버는 보통 데이터를 받아서 버퍼에 쌓아두는 방식이 흔하다.
    

### **9.2.3.4 정렬 관련 상태 변수**

정렬이 실제로 얼마나 수행되었는지 상태 변수로 확인할 수 있다.

- Sort_merge_passes
    
    멀티 머지 처리 횟수
    
- Sort_range
    
    인덱스 레인지 스캔 결과 정렬 횟수
    
- Sort_scan
    
    풀 스캔 결과 정렬 횟수
    
- Sort_rows
    
    지금까지 정렬한 전체 레코드 수
    

정렬 튜닝은 보통 이 값을 보고

- 얼마나 많이 정렬하는지
- 디스크 머지가 발생했는지

를 확인하는 방식으로 접근한다.

## **9.2.4 GROUP BY 처리**

GROUP BY 작업도 인덱스를 사용하는 경우와 그렇지 않은 경우로 나눠볼 수 있다.

처리방식은 다음 3가지이다.

- 인덱스 스캔
- 루스 인덱스 스캔
- 임시 테이블 사용

### **9.2.4.1 인덱스 스캔을 이용한 GROUP BY**

- GROUP BY 컬럼 순서대로 인덱스가 존재하는 경우
- 인덱스를 차례대로 읽으며 그룹핑

### **9.2.4.2 루스 인덱스 스캔을 이용한 GROUP BY**

- 루스 인덱스 스캔 방식은 인덱스를 건너뛰면서 필요한 부분만 읽어서 가져온다.
- MIN, MAX 같은 집계 함수에 유리한 방식이다.

```sql
-- salaries 테이블의 인덱스가 (emp_no, from_date)로 생성되어 있다.
mysql> EXPLAIN
SELECT emp_no
FROM salaries
WHERE from_date = '1985-03-01'
GROUP BY emp_no;
```

### **9.2.4.3 임시 테이블을 사용하는 GROUP BY**

- 인덱스를 사용할 수 없는 경우
- 내부 임시 테이블 생성
- 실행 계획의 Extra 컬럼에 Using temporary 표시
- MySQL8.0 버전부터는 GROUP BY로 인해 묵시적인 정렬이 수행되지 않는다.
    - 내부적으로 GROUP BY 컬럼 조합을 유니크 키로 하는 임시 테이블을 사용해, 중복을 제거하면서 집계 함수를 누적 계산하는 방식으로 처리된다.

## **9.2.5 DISTINCT 처리**

DISTINCT는 MIN(), MAX() 또는 COUNT() 같은 집합 함수와 함께 사용되는 경우와 집합 함수가 없는 경우의
2가지로 구분해서 살펴봐야 한다.

각 경우에 DISTINCT 키워드가 영향을 미치는 범위가 달라지기 때문이다.

### **9.2.5.1 SELECT DISTINCT …**

- 모든 SELECT 컬럼 조합을 유니크하게 만듦
- 내부적으로 GROUP BY와 유사하게 동작
- 인덱스 사용 불가 시 임시 테이블 필요

### **9.2.5.2 집합 함수와 함께 사용된 DISTINCT**

- COUNT(DISTINCT col)
- DISTINCT는 함수 인자에만 적용
- 실행 계획과 결과가 SELECT DISTINCT와 다름

주의

- DISTINCT는 함수가 아님
- DISTINCT(col1), col2 같은 문법은 의미 없음

## **9.2.6 내부 임시 테이블 활용**

MySQL 엔진이 **자동으로 생성하는 임시 테이블**

- 사용자 TEMPORARY TABLE과 다름
- 쿼리 종료 시 자동 삭제
- 세션 간 공유 불가

### **9.2.6.1 메모리 임시 테이블과 디스크 임시 테이블**

MySQL 8.0 기준

- 메모리: TempTable 엔진
- 디스크: InnoDB 또는 MMAP

전환 기준

- 테이블 크기
- 컬럼 타입(BLOB, TEXT)
- 시스템 변수

### **9.2.6.2 임시 테이블이 필요한 대표 쿼리**

- ORDER BY + GROUP BY
- DISTINCT + ORDER BY
- UNION, UNION DISTINCT
- 파생 테이블(DERIVED)

### **9.2.6.3 임시 테이블이 디스크에 생성되는 경우**

- 내부 임시 테이블은 기본적으로 메모리에 생성됨
- 메모리에서 처리할 수 없는 경우 메모리 → 디스크 전환 가능
- 디스크 임시 테이블은 tmpdir에 생성
- 파일은 쿼리 종료 시 삭제됨

### **9.2.6.4 임시 테이블 관련 상태 변수**

- Created_tmp_tables
    - 쿼리의 처리를 위해 만들어진 내부 임시 테이블의 개수를 누적하는 상태 값이다.
    - 이 값은 내부 임시 테이블이 메모리에 만들어졌는지 디스크에 만들어졌는지를 구분하지 않고 모두 누적한다.
- Created_tmp_disk_tables
    - 디스크에 내부 임시 테이블이 만들어진 개수만 누적해서 가지고 있는 상태 값이다.
