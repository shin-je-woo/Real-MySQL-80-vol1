# 08. 인덱스

이 장에서는 MySQL에서 사용하는 인덱스의 구조와 동작 방식을 중심으로 **디스크 I/O, B-Tree 인덱스의 특성, 그리고 인덱스를 통해 데이터를 읽는 방식**을 설명한다.

인덱스는 단순한 성능 최적화 수단이 아니라 **쿼리 실행 계획과 스토리지 접근 방식을 결정하는 핵심 요소**다.

## **8.1 디스크 읽기 방식**

인덱스는 결국 **디스크에서 읽는 양을 줄이기 위한 구조**다.

그래서 인덱스를 이해하려면 먼저 디스크 I/O 특성을 이해해야 한다.

### **8.1.1 HDD와 SSD**

- CPU와 메모리는 빠르지만 디스크는 상대적으로 느림
- DB 병목은 대부분 디스크 I/O에서 발생
- SSD는 HDD 대비 랜덤 I/O가 개선되지만, 메모리 대비 여전히 느림
- 결론은 **디스크 접근을 줄이는 것이 튜닝의 핵심**

### **8.1.2 랜덤 I/O와 순차 I/O**

<img width="293" height="296" alt="image" src="https://github.com/user-attachments/assets/d5c68df2-05a6-420d-af69-3ec08dc08b98" />

- **순차 I/O**
    - 연속된 위치의 데이터를 한 번에 읽는다.
    - 디스크 헤드 이동이 적다.
    - 처리 효율이 높다.
- **랜덤 I/O**
    - 매번 다른 위치를 읽는다.
    - 디스크 헤드 이동 비용이 크다.
    - 작은 데이터라도 I/O 호출 횟수가 늘어나면 비용이 커진다.

인덱스 튜닝의 본질은 다음 두 가지다.

- 랜덤 I/O 횟수를 줄인다.
- 꼭 필요한 데이터만 읽는다.

## **8.2 인덱스란**

인덱스는 **정렬된 키와 레코드 위치 정보를 가진 자료 구조**다.

책의 찾아보기와 동일한 개념이다.

### **인덱스의 기본 성질**

- 키 값 기준으로 정렬되어 있다.
- 빠른 검색이 가능하다.
- 대신 쓰기 비용이 증가한다.

즉, 인덱스는 다음을 교환하는 구조다.

- 읽기 성능 향상
- 쓰기 성능과 저장 공간 희생

### **인덱스와 데이터 파일의 차이**

- 데이터 파일은 일반적으로 정렬되지 않는다.
- 인덱스는 항상 키 값 기준으로 정렬된다.
- 정렬 비용을 미리 지불해두고 조회 시 이득을 얻는다.

## **8.3 B-Tree 인덱스**

B-Tree는 MySQL에서 가장 일반적으로 사용되는 인덱스 구조다.

키 값이 정렬된 상태로 유지되는 트리 구조다.

<img width="641" height="491" alt="image" src="https://github.com/user-attachments/assets/341d580e-a4ed-498f-8614-0e9a883bf9b4" />

### **8.3.1 구조와 특성**

B-Tree 인덱스는 다음 노드들로 구성된다.

- 루트 노드
- 브랜치 노드
- 리프 노드

검색은 항상 루트 노드부터 시작해 리프 노드까지 내려간다.

### **8.3.1.1 InnoDB에서의 매우 중요한 특징**

InnoDB는 **테이블 자체가 프라이머리 키 기준의 클러스터링 구조**다.

- 프라이머리 키 인덱스의 리프 노드에는 실제 레코드의 모든 컬럼 값이 저장된다.
- 즉 프라이머리 키 인덱스 = 데이터 파일이다.

반면 세컨더리 인덱스는 다르다.

- 세컨더리 인덱스의 리프 노드에는 세컨더리 인덱스 키 값과 프라이머리 키 값이 저장된다.
- 실제 레코드 전체는 포함하지 않는다.

따라서 세컨더리 인덱스를 통해 레코드를 읽을 때는 다음 과정이 필요하다.

- 세컨더리 인덱스에서 프라이머리 키를 찾는다.
- 프라이머리 키로 클러스터링 인덱스를 다시 탐색해 레코드를 읽는다.

<img width="718" height="386" alt="image" src="https://github.com/user-attachments/assets/1a218892-822e-4a34-bdb8-20a40662520b" />

## **8.3.2 B-Tree 인덱스 키 추가와 삭제**

### **인덱스 키 추가**

- INSERT 또는 인덱스 컬럼 UPDATE 시 발생한다.
- 리프 노드에 공간이 없으면 페이지 분할이 발생한다.
- 페이지 분할은 상위 노드까지 영향을 줄 수 있다.

### **인덱스 키 삭제**

- 리프 노드에서 키만 제거한다.
- 공간은 바로 반환되지 않을 수 있다.
- InnoDB에서는 지연 정리가 가능하다.

### **인덱스 키 변경**

- B-Tree 구조상 키 값 자체를 수정할 수 없다.
- 기존 키 삭제 후 새 키 추가로 처리된다.
- 결과적으로 삭제 + 추가 비용이 발생한다.

## **8.3.3 B-Tree 인덱스 키 검색**

인덱스 검색은 다음 특징을 가진다.

- 루트 → 브랜치 → 리프 순으로 탐색한다.
- 동등 비교와 범위 비교에 모두 적합하다.
- 인덱스 키에 변형이 가해지면 사용할 수 없다.
- 함수 연산이나 타입 변환이 있으면 인덱스가 무력화된다.

## **8.3.4 B-Tree 인덱스를 통한 데이터 읽기 방식**

B-Tree 인덱스를 통한 읽기 방식은 크게 네 가지로 나뉜다.

- 인덱스 레인지 스캔
- 인덱스 풀 스캔
- 루스 인덱스 스캔
- 인덱스 스킵 스캔

## **8.3.4.1 인덱스 레인지 스캔**

가장 일반적이고 효율적인 방식이다.

- 동작 과정
    - 인덱스 탐색으로 시작 위치를 찾는다.
    - 이후 리프 노드를 순서대로 스캔한다.

<img width="546" height="433" alt="image" src="https://github.com/user-attachments/assets/f83c5507-9943-45fc-814e-ce3e4ed9ae50" />

- 특징
    - 범위가 좁을수록 효율적이다.
    - 인덱스 자체 스캔은 상대적으로 순차적이지만
    - 테이블 레코드를 추가로 읽는 순간 랜덤 I/O가 섞일 수 있다.
    - 인덱스를 사용하는 대표적인 방식이다.
 
<img width="631" height="442" alt="image" src="https://github.com/user-attachments/assets/863622e2-c04a-4022-84f3-1f7b2ccc4e7f" />

## **8.3.4.2 인덱스 풀 스캔**

- 인덱스 처음부터 끝까지 전부 스캔
- 인덱스 선행 컬럼 조건이 없거나, 조건이 약할 때 발생
- 테이블 풀 스캔보다 나을 수는 있지만 비용이 크다.

<img width="538" height="429" alt="image" src="https://github.com/user-attachments/assets/bb97eeef-130a-4d25-a92c-b418cb1fbff2" />

## **8.3.4.3 루스 인덱스 스캔**

- 불필요한 키를 건너뛰며 읽는 방식
- GROUP BY, MIN, MAX 같은 집계 최적화에 사용된다.
- 제약이 많아 항상 가능한 것은 아니다.

<img width="465" height="598" alt="image" src="https://github.com/user-attachments/assets/78664d23-dc33-4b95-a4f9-22fd7990b63d" />

## **8.3.4.4 인덱스 스킵 스캔**

MySQL 8.0부터 본격적으로 지원된다.

- 선행 컬럼 조건이 없어도 인덱스를 활용하려는 최적화 방식이다.
- 내부적으로 선행 컬럼의 가능한 값들을 순회한다.
- 조회 조건에 없는 선행 컬럼의 유니크한 값의 개수가 적어야 한다.
- 커버링 인덱스여야 실효성이 높다.

<img width="404" height="419" alt="image" src="https://github.com/user-attachments/assets/108cadc6-2d77-4a4c-8341-591975cb8839" />

## **8.3.5 다중 컬럼 인덱스**

다중 컬럼 인덱스는 **컬럼 순서가 핵심**이다.

- 항상 왼쪽 컬럼부터 정렬된다.
- 왼쪽 컬럼 조건이 없으면 범위 결정에 사용할 수 없다.

<img width="369" height="536" alt="image" src="https://github.com/user-attachments/assets/801325b2-cce3-46fa-8866-5f8cbf3bf358" />

## **8.3.6 B-Tree 인덱스의 정렬과 스캔 방향**

- 인덱스는 정방향과 역방향 모두 스캔 가능하다.
- 인덱스는 생성 시 ASC 또는 DESC로 정렬된다.
- MySQL 8.0부터 컬럼별 혼합 정렬이 가능하다.
- ORDER BY와 LIMIT 최적화에 매우 중요하다.

<img width="424" height="453" alt="image" src="https://github.com/user-attachments/assets/bddfc5c1-1f72-4a60-a1e8-03b75a9fe8b5" /> <br>

<img width="473" height="237" alt="image" src="https://github.com/user-attachments/assets/d493670e-9c2f-4b57-847d-52f38a5490ef" />

## **8.3.7 B-Tree 인덱스의 가용성과 효율성**

### **작업 범위 결정 조건**

- 동등 비교
- 범위 비교
- 좌측 일치 LIKE

### **사용할 수 없는 경우**

- 부정형 비교 NOT EQUAL, NOT IN, NOT BETWEEN
- 컬럼에 함수 적용
- 타입 변환
- 선행 컬럼 조건 누락

## **8.4 R-Tree 인덱스**

공간 데이터 검색을 위한 인덱스다.

B-Tree가 1차원 정렬 값이라면, R-Tree는 **2차원 이상의 공간 범위**를 다룬다.

### **8.4.1 공간 데이터 타입**

MySQL 공간 타입 예

- POINT
- LINE
- POLYGON
- GEOMETRY 슈퍼 타입

### **8.4.2 MBR 개념**

R-Tree 인덱스의 핵심 개념은 **MBR(Minimum Bounding Rectangle)**

- 각 도형을 감싸는 **최소 사각형**
- 실제 도형이 아니라 **도형의 외곽 범위**

<img width="383" height="201" alt="image" src="https://github.com/user-attachments/assets/2b1c74ed-189c-4017-94e1-9d04528966a3" />

R-Tree는 도형 자체가 아니라 MBR 최소 경계 사각형을 기준으로 인덱싱한다.

### **8.4.3 R-Tree 구조**

- 리프 레벨에 개별 도형의 MBR이 저장된다.
- 상위 레벨로 갈수록 여러 MBR을 감싸는 더 큰 MBR이 저장된다.

<img width="381" height="279" alt="image" src="https://github.com/user-attachments/assets/6655b429-57b5-436e-97f9-eefe1b702a2b" /> <br>

<img width="378" height="289" alt="image" src="https://github.com/user-attachments/assets/43a6476b-df9e-4bd8-9a05-b466383f9404" /> <br>

<img width="587" height="442" alt="image" src="https://github.com/user-attachments/assets/21193273-7908-4ab8-908d-a966ecab3032" />

### **8.4.4  공간 검색에서 인덱스를 쓰는 방법**

- R-Tree는 **포함 관계 기반 함수**에서 인덱스가 동작한다.

대표 함수

- ST_Contains()
- ST_Within()

검색 방식

1. 먼저 MBR 기준으로 후보를 줄인다.
2. 필요한 경우 거리 계산 함수로 추가 필터링한다.

<img width="371" height="342" alt="image" src="https://github.com/user-attachments/assets/455a2105-4be6-4116-be20-0c926ff76a58" />

주의

- ST_Distance 계열만으로 조건을 걸면 인덱스가 효율적으로 쓰이지 않을 수 있다.
- 먼저 ST_Contains 또는 ST_Within으로 후보를 줄이는 접근이 필요하다.

## **8.5 전문 검색 인덱스**

### **8.5.1 전문 검색 인덱스 개요**

- 일반 B-Tree 인덱스는 컬럼 전체 텍스트 검색에 부적합
- 전문 검색 인덱스는 **문서 전체를 분석하여 토큰 단위로 인덱싱**
- InnoDB에서도 전문 검색 인덱스 지원

### **8.5.2 전문 검색 처리 흐름**

전문 검색 인덱스 생성 과정

1. 문서 분석
2. 토큰 분리
3. 불용어 제거
4. 인덱스 저장

### **8.5.3 어근 분석 알고리즘**

- 단어의 **원형(어근)** 을 기준으로 인덱싱한다.
- 언어 의존적
- 형태소 분석이 필요할 수 있다.
- MySQL은 MeCab 플러그인 지원

### **8.5.4 n-gram 알고리즘**

- 텍스트를 **n글자 단위로 분리**
- 언어 독립적
- 보통 2-gram(bi-gram) 사용
- MySQL 기본 전문 검색 방식
- 예시) question → qu ue es st ti io on

### **8.5.5 불용어 처리**

불용어는 의미 없는 단어를 제거하기 위한 장치다.

하지만 환경에 따라 오히려 혼란을 줄 수 있어 조정이 필요하다.

관리 방법

- 서버 내장 불용어 사용
- 사용자 정의 불용어 파일 사용
- 불용어 처리 완전 비활성화 가능

주의

- 설정 변경 후 기존 인덱스에는 반영되지 않음
- 반드시 인덱스 재생성 필요

### **8.5.6 전문 검색 인덱스 사용 조건**

- LIKE 검색은 전문 검색 인덱스를 사용하지 않는다.
- 테이블에 FULLTEXT 인덱스가 있어야 한다.
- 검색은 MATCH, AGAINST 문법을 사용해야 한다.

```sql
SELECT *
FROM tb_test
WHERE MATCH(doc_body) AGAINST('애플' IN BOOLEAN MODE);
```

## **8.6 함수 기반 인덱스**

일반 인덱스는 컬럼 값 그대로 만든다.

하지만, 가공 값에 대한 검색이 필요한 경우가 있다.

예를 들어, first_name과 last_name을 합친 full_name 검색 같은 케이스다.

### **8.6.1 가상 컬럼 기반 인덱스**

- 가상 컬럼을 추가
- 해당 컬럼에 인덱스 생성

특징

- 테이블 구조 변경 필요
- 내부적으로 B-Tree 인덱스와 동일

### **8.6.2 함수 직접 사용 인덱스**

- 테이블 구조 변경 없음
- 함수 결과에 직접 인덱스 생성

주의사항

- WHERE 절의 표현식이 인덱스 생성 시 표현식과 **완전히 동일**해야 한다.
- 겉보기 결과가 같아도 표현식이 다르면 옵티마이저가 다른 식으로 판단할 수 있다.

## **8.7 멀티 밸류 인덱스**

일반 인덱스는 한 레코드가 한 인덱스 키를 갖는 형태다.

멀티 밸류 인덱스는 한 레코드가 **여러 인덱스 키**를 갖게 만든다.

대표적으로 JSON 배열 요소 인덱싱에 사용한다.

조회 예시

- JSON 배열 내부 값 검색
- MEMBER OF
- JSON_CONTAINS
- JSON_OVERLAPS

```sql
SELECT *
FROM user
WHERE 360 MEMBER OF (credit_info->'$.credit_scores');
```

## **8.8 클러스터링 인덱스**

InnoDB에서 클러스터링 인덱스는 개념이 아니라 **테이블의 저장 방식 그 자체**다.

### **8.8.1 개념**

- 프라이머리 키 자체가 **클러스터링 인덱스이다.**
- InnoDB 테이블은 **프라이머리 키 기준으로 정렬 저장된다.**
- 클러스터링 인덱스 리프 노드에는 레코드 전체 컬럼이 저장된다.
- 즉, 테이블은 하나의 거대한 인덱스 구조로 관리된다.

<img width="502" height="438" alt="image" src="https://github.com/user-attachments/assets/029cfd77-b493-4787-a03d-258f5f81f2cc" />

### **8.8.2 프라이머리 키 변경의 영향**

- 프라이머리 키 변경 시 레코드의 물리적 위치 변경이 발생한다.
- 결과적으로 UPDATE 비용 크다.

<img width="487" height="431" alt="image" src="https://github.com/user-attachments/assets/b31b95d3-1b57-431b-b841-0b003ec7c800" />

### **8.8.3 프라이머리 키가 없을 때 InnoDB 선택 순서**

InnoDB는 클러스터링 키가 반드시 필요하므로, 없으면 다음 우선순위로 선택한다.

1. 명시된 프라이머리 키
2. NOT NULL 유니크 인덱스 중 첫 번째
3. 내부적으로 추가되는 증가 컬럼

권장 사항으로 InnoDB 테이블은 프라이머리 키를 **반드시 명시**하는 것이 좋다.

### **8.8.4 세컨더리 인덱스와의 관계**

InnoDB 세컨더리 인덱스 리프에는 레코드 주소가 아니라 프라이머리 키 값이 저장된다.

그래서 세컨더리 인덱스 기반 조회는 보통 다음 단계가 된다.

1. 세컨더리 인덱스에서 프라이머리 키를 찾는다.
2. 프라이머리 키로 클러스터링 인덱스를 다시 탐색
    
### **8.8.5 클러스터링 인덱스의 장점과 단점**

장점

- 프라이머리 키 기반 조회 매우 빠름
- 프라이머리 키 범위 검색이 효율적

단점

- INSERT, UPDATE, DELETE 비용 증가
- 세컨더리 인덱스는 프라이머리 키 값을 포함하므로 프라이머리 키가 커질수록 세컨더리 인덱스 크기가 커진다.
- 프라이머리 키 크기가 크면 모든 인덱스 영향

## **8.9 유니크 인덱스**

### **8.9.1 개념**

유니크 인덱스는 성능 기능이라기보다 **중복을 금지하는 제약**에 가깝다.

특징

- NULL 허용 가능
- 프라이머리 키와는 목적이 다르다.

### **8.9.2 일반 세컨더리 인덱스와 비교**

**읽기**

- 유니크라서 무조건 빠르다고 보기 어렵다.
- 보통 읽기에서 큰 차이를 만들지 않는다.
- 유니크가 빨라 보이는 경우는 단순히 읽는 건수가 적기 때문인 해석이 더 맞다.

**쓰기**

- 중복 체크가 추가로 필요
- 그래서 일반 세컨더리 인덱스보다 느릴 수 있다.
- InnoDB는 변경 버퍼 같은 최적화가 있어도 유니크는 중복 체크 때문에 이점을 다 못 얻는 방향이 생긴다.

### **8.9.3 사용 시 주의사항**

- 성능 향상 목적만으로 유니크 인덱스 생성 금지
- 이미 유니크 인덱스가 있다면 동일 컬럼에 일반 인덱스 중복 생성 불필요

## **8.10 외래키**

외래키는 InnoDB에서만 지원되며, 무결성에는 도움이 되지만 **잠금 전파와 대기**라는 비용이 있다.

### **8.10.1 외래키 기본 동작**

- 외래키를 생성하면 관련 컬럼에 인덱스가 필요하며, 없는 경우 자동 생성될 수 있다.
- 외래키가 제거되지 않으면 자동 생성된 인덱스도 임의로 삭제할 수 없다.

### **8.10.2 잠금과 대기 메커니즘**

InnoDB 외래키의 핵심 특징 두 가지

- 테이블의 변경(쓰기 잠금)이 발생하는 경우에만 잠금 경합(잠금 대기)이 발생한다.
- 외래키와 연관되지 않은 컬럼의 변경은 최대한 잠금 경합(잠금 대기)을 발생시키지 않는다.

### **8.10.2.1 자식 테이블 변경이 대기하는 경우**

상황

- 커넥션 1이 부모 레코드를 변경하며 쓰기 잠금을 잡고 있다.
- 커넥션 2가 자식에서 외래키 컬럼을 변경하거나 삽입하려면 부모 존재 확인이 필요해서 대기할 수 있다.

요지

- 자식의 외래키 컬럼 변경은 부모 확인 때문에 부모 잠금 영향을 받을 수 있다.

### **8.10.2.2 부모 테이블 변경이 대기하는 경우**

상황

- 커넥션 1이 자식 레코드를 변경하며 쓰기 잠금을 잡음
- 커넥션 2가 부모 레코드를 삭제하려고 하면 ON DELETE CASCADE 같은 동작 때문에 자식 쪽 잠금에 막힐 수 있다.

모델링 관점 메시지

- 외래키를 물리적으로 강제하면 무결성은 좋아질 수 있다.
- 반면, 잠금이 다른 테이블로 확장되며 동시성에 영향을 줄 수 있다.
- 고부하 환경에서는 특히 신중해야 한다.

## **8장 전체 정리**

- 인덱스는 디스크 I/O를 줄이는 구조이며, 특히 랜덤 I/O 감소가 핵심이다.
- B-Tree는 MySQL의 기본 인덱스 구조로, 레인지 스캔이 대표적인 효율 경로다.
- 다중 컬럼 인덱스는 왼쪽 컬럼부터의 정렬 특성이 핵심이며, 조건 누락이나 변형은 효율을 크게 떨어뜨린다.
- R-Tree는 공간 데이터용이며, MBR 포함 관계 기반 함수로 후보를 줄여야 인덱스를 제대로 쓴다.
- 전문 검색은 토큰 기반이며, n-gram과 불용어 설정, MATCH AGAINST 문법이 실사용의 핵심 제약이다.
- 함수 기반 인덱스는 가공 값 검색을 가능하게 하지만, 표현식이 인덱스 정의와 완전히 같아야 한다.
- 멀티 밸류 인덱스는 JSON 배열 요소를 인덱싱해 MEMBER OF, JSON_CONTAINS 같은 패턴에 대응한다.
- InnoDB 클러스터링은 테이블 저장 방식 자체이며, 프라이머리 키 설계가 전체 인덱스 크기와 쓰기 비용에 직결된다.
- 유니크 인덱스는 읽기보다 쓰기에서 비용 차이가 나기 쉬우며, 필요할 때만 제약으로 사용해야 한다.
- 외래키는 무결성 장점이 있지만 잠금 전파로 인해 동시성 비용을 만들 수 있어, 운영 환경에 맞게 선택해야 한다.
