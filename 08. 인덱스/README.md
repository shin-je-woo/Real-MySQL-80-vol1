# 08. 인덱스

이 장에서는 MySQL에서 사용하는 인덱스의 구조와 동작 방식을 중심으로 **디스크 I/O, B-Tree 인덱스의 특성, 그리고 인덱스를 통해 데이터를 읽는 방식**을 설명한다.

인덱스는 단순한 성능 최적화 수단이 아니라 **쿼리 실행 계획과 스토리지 접근 방식을 결정하는 핵심 요소**다.

## **8.1 디스크 읽기 방식**

인덱스는 결국 **디스크에서 읽는 양을 줄이기 위한 구조**다.

그래서 인덱스를 이해하려면 먼저 디스크 I/O 특성을 이해해야 한다.

### **8.1.1 HDD와 SSD**

- CPU와 메모리는 매우 빠르다.
- 디스크는 상대적으로 매우 느리다.
- DB 서버 성능 병목은 대부분 디스크 I/O에서 발생한다.
- SSD는 HDD보다 랜덤 I/O 성능이 크게 개선되었다.
- 그래도 메모리와 비교하면 디스크는 여전히 느리다.

결론적으로 DB 성능 튜닝의 핵심은 디스크 접근을 최소화하는 것이다.

### **8.1.2 랜덤 I/O와 순차 I/O**

<img width="293" height="296" alt="image" src="https://github.com/user-attachments/assets/d5c68df2-05a6-420d-af69-3ec08dc08b98" />

- **순차 I/O**
    - 연속된 위치의 데이터를 한 번에 읽는다.
    - 디스크 헤드 이동이 적다.
    - 처리 효율이 높다.
- **랜덤 I/O**
    - 매번 다른 위치를 읽는다.
    - 디스크 헤드 이동 비용이 크다.
    - 작은 데이터라도 I/O 호출 횟수가 늘어나면 매우 비싸다.

인덱스 튜닝의 본질은 다음 두 가지다.

- 랜덤 I/O 횟수를 줄인다.
- 꼭 필요한 데이터만 읽는다.

## **8.2 인덱스란**

인덱스는 **정렬된 키와 레코드 위치 정보를 가진 자료 구조**다.

책의 찾아보기와 동일한 개념이다.

### **인덱스의 기본 성질**

- 키 값 기준으로 정렬되어 있다.
- 빠른 검색이 가능하다.
- 대신 쓰기 비용이 증가한다.

즉, 인덱스는 다음을 교환하는 구조다.

- 읽기 성능 향상
- 쓰기 성능과 저장 공간 희생

### **인덱스와 데이터 파일의 차이**

- 데이터 파일은 일반적으로 정렬되지 않는다.
- 인덱스는 항상 키 값 기준으로 정렬된다.
- 정렬 비용을 미리 지불해두고 조회 시 이득을 얻는다.

## **8.3 B-Tree 인덱스**

B-Tree는 MySQL에서 가장 일반적으로 사용되는 인덱스 구조다.

키 값이 정렬된 상태로 유지되는 트리 구조다.

<img width="641" height="491" alt="image" src="https://github.com/user-attachments/assets/341d580e-a4ed-498f-8614-0e9a883bf9b4" />

### **8.3.1 구조와 특성**

B-Tree 인덱스는 다음 노드들로 구성된다.

- 루트 노드
- 브랜치 노드
- 리프 노드

검색은 항상 루트 노드부터 시작해 리프 노드까지 내려간다.

### **8.3.1.1 InnoDB에서의 매우 중요한 특징**

InnoDB에서는 **데이터 파일 자체가 프라이머리 키 인덱스**다.

- 프라이머리 키 인덱스의 리프 노드는 실제 레코드의 모든 컬럼 값을 가진다.
- 즉 프라이머리 키 인덱스 = 데이터 파일이다.

반면 세컨더리 인덱스는 다르다.

- 세컨더리 인덱스의 리프 노드는 세컨더리 인덱스 키 값과 프라이머리 키 값을 가진다.
- 실제 레코드 전체는 포함하지 않는다.

따라서 세컨더리 인덱스를 통해 레코드를 읽을 때는 다음 과정이 필요하다.

- 세컨더리 인덱스 검색
- 프라이머리 키 인덱스 재검색

이 추가 단계가 성능에 영향을 준다.

<img width="558" height="405" alt="image" src="https://github.com/user-attachments/assets/09be6504-a5fe-4e4d-8257-8b90f84016b5" />

<img width="718" height="386" alt="image" src="https://github.com/user-attachments/assets/1a218892-822e-4a34-bdb8-20a40662520b" />

## **8.3.2 B-Tree 인덱스 키 추가와 삭제**

### **인덱스 키 추가**

- INSERT 또는 인덱스 컬럼 UPDATE 시 발생한다.
- B-Tree에서 저장 위치를 찾는다.
- 리프 노드에 공간이 없으면 페이지 분할이 발생한다.
- 페이지 분할은 상위 노드까지 영향을 줄 수 있다.
- 쓰기 비용이 증가한다.

### **인덱스 키 삭제**

- 리프 노드에서 키만 제거한다.
- 공간은 바로 반환되지 않을 수 있다.
- InnoDB에서는 지연 정리가 가능하다.

### **인덱스 키 변경**

- B-Tree 구조상 키 값 자체를 수정할 수 없다.
- 기존 키 삭제 후 새 키 추가로 처리된다.
- 결과적으로 삭제 + 추가 비용이 발생한다.

## **8.3.3 B-Tree 인덱스 키 검색**

인덱스 검색은 다음 특징을 가진다.

- 루트 → 브랜치 → 리프 순으로 탐색한다.
- 동등 비교와 범위 비교에 모두 적합하다.
- 인덱스 키에 변형이 가해지면 사용할 수 없다.
- 함수 연산이나 타입 변환이 있으면 인덱스가 무력화된다.

## **8.3.4 B-Tree 인덱스를 통한 데이터 읽기 방식**

B-Tree 인덱스를 통한 읽기 방식은 크게 네 가지로 나뉜다.

- 인덱스 레인지 스캔
- 인덱스 풀 스캔
- 루스 인덱스 스캔
- 인덱스 스킵 스캔

## **8.3.4.1 인덱스 레인지 스캔**

가장 일반적이고 효율적인 방식이다.

- 동작 과정
    - 인덱스 탐색으로 시작 위치를 찾는다.
    - 이후 리프 노드를 순서대로 스캔한다.
    - 필요한 레코드만 읽는다.

<img width="546" height="433" alt="image" src="https://github.com/user-attachments/assets/f83c5507-9943-45fc-814e-ce3e4ed9ae50" />

- 특징
    - 랜덤 I/O와 순차 I/O가 혼합된다.
    - 범위가 좁을수록 효율이 좋다.
    - 인덱스를 사용하는 대표적인 방식이다.
 
<img width="631" height="442" alt="image" src="https://github.com/user-attachments/assets/863622e2-c04a-4022-84f3-1f7b2ccc4e7f" />

## **8.3.4.2 인덱스 풀 스캔**

- 인덱스의 처음부터 끝까지 모두 읽는다.
- 보통 인덱스 선행 컬럼 조건이 없는 경우 발생한다.
- 테이블 풀 스캔보다는 저렴할 수 있다.
- 그래도 효율적인 방식은 아니다.

<img width="538" height="429" alt="image" src="https://github.com/user-attachments/assets/bb97eeef-130a-4d25-a92c-b418cb1fbff2" />

## **8.3.4.3 루스 인덱스 스캔**

- 필요 없는 인덱스 키는 건너뛰면서 읽는다.
- GROUP BY, MIN, MAX 같은 집계 최적화에 사용된다.
- 모든 인덱스에서 가능한 것은 아니다.
- 제약 조건이 많다.

<img width="465" height="598" alt="image" src="https://github.com/user-attachments/assets/78664d23-dc33-4b95-a4f9-22fd7990b63d" />

## **8.3.4.4 인덱스 스킵 스캔**

MySQL 8.0부터 본격적으로 지원된다.

- 선행 컬럼 조건이 없어도 인덱스를 활용한다.
- 내부적으로 선행 컬럼의 가능한 값들을 순회한다.
- 조회 조건에 없는 선행 컬럼의 유니크한 값의 갯수가 적어야 한다.
- 커버링 인덱스여야 실효성이 높다.

<img width="404" height="419" alt="image" src="https://github.com/user-attachments/assets/108cadc6-2d77-4a4c-8341-591975cb8839" />

## **8.3.5 다중 컬럼 인덱스**

다중 컬럼 인덱스는 **컬럼 순서가 핵심**이다.

- 항상 왼쪽 컬럼부터 정렬된다.
- 왼쪽 컬럼 조건이 없으면 범위 결정에 사용할 수 없다.

<img width="369" height="536" alt="image" src="https://github.com/user-attachments/assets/801325b2-cce3-46fa-8866-5f8cbf3bf358" />

## **8.3.6 B-Tree 인덱스의 정렬과 스캔 방향**

- 인덱스는 생성 시 ASC 또는 DESC로 정렬된다.
- MySQL 8.0부터 컬럼별 혼합 정렬이 가능하다.
- 인덱스는 정방향과 역방향 모두 스캔 가능하다.
- ORDER BY와 LIMIT 최적화에 매우 중요하다.

<img width="424" height="453" alt="image" src="https://github.com/user-attachments/assets/41e6b1f2-a444-4864-9d00-ea8934943ec7" />

<img width="473" height="237" alt="image" src="https://github.com/user-attachments/assets/a66857f3-f006-4297-b740-e305ae23d180" />

## **8.3.7 B-Tree 인덱스의 가용성과 효율성**

### **작업 범위 결정 조건**

- 동등 비교
- 범위 비교
- 좌측 일치 LIKE

### **사용할 수 없는 경우**

- NOT EQUAL
- NOT IN
- NOT BETWEEN
- 함수 적용
- 타입 변환
- 선행 컬럼 조건 누락

## **8.4 R-Tree 인덱스**

### **8.4.1 개념과 목적**

- R-Tree는 **공간 데이터(Spatial Data)** 를 위한 인덱스
- 1차원 값 기준인 B-Tree와 달리 **2차원 이상 공간 좌표**를 인덱싱
- MySQL 공간 인덱스는 내부적으로 **R-Tree 알고리즘** 사용
- B-Tree와 유사하게 트리 구조를 가지지만, 키 값 대신 **공간 범위**를 저장
- 적용 대상
    - 위치 기반 서비스
    - GIS
    - 좌표 기반 검색

### **8.4.2 Geometry 데이터 타입**

MySQL이 제공하는 대표적인 공간 데이터 타입

- POINT
- LINE
- POLYGON
- GEOMETRY (슈퍼 타입)

→ **GEOMETRY는 모든 공간 객체를 저장 가능**

### **8.4.3 MBR 개념**

R-Tree 인덱스의 핵심 개념은 **MBR(Minimum Bounding Rectangle)**

- 각 도형을 감싸는 **최소 사각형**
- 실제 도형이 아니라 **도형의 외곽 범위**

<img width="383" height="201" alt="image" src="https://github.com/user-attachments/assets/2b1c74ed-189c-4017-94e1-9d04528966a3" />

- R-Tree는 실제 도형이 아닌 **MBR 간의 포함 관계**를 기준으로 인덱싱

### **8.4.4 R-Tree 구조**

- 최하위 레벨
    - 실제 도형의 MBR
- 중간 레벨
    - 여러 MBR을 감싸는 상위 MBR
- 최상위 레벨
    - 전체 공간을 감싸는 MBR

<img width="381" height="279" alt="image" src="https://github.com/user-attachments/assets/925085ba-9bab-47ea-a062-cc92ea2306e7" />

<img width="378" height="289" alt="image" src="https://github.com/user-attachments/assets/53dc34d5-5a9a-4655-96db-4d8343f50eb3" />

결과적으로

- 루트 노드
    - 최상위 MBR
- 브랜치 노드
    - 중간 MBR
- 리프 노드
    - 실제 도형의 MBR

<img width="587" height="442" alt="image" src="https://github.com/user-attachments/assets/4b7bf219-4725-4a5d-bcef-51ec530f931b" />

### **8.4.5 공간 검색 방식**

R-Tree 인덱스가 사용되려면 **포함 관계 비교 함수**를 사용해야 한다.

대표 함수

- ST_Contains()
- ST_Within()

검색 방식

1. 먼저 MBR 기준으로 후보를 줄임
2. 필요한 경우 실제 거리 계산으로 추가 필터링

<img width="371" height="342" alt="image" src="https://github.com/user-attachments/assets/455a2105-4be6-4116-be20-0c926ff76a58" />

주의

- ST_Distance 계열 함수만 사용하면 인덱스 활용 불가
- 반드시 ST_Contains 또는 ST_Within을 선행 조건으로 사용

## **8.5 전문 검색 인덱스**

### **8.5.1 전문 검색 인덱스 개요**

- 일반 B-Tree 인덱스는 컬럼 전체 텍스트 검색에 부적합
- 전문 검색 인덱스는 **문서 전체를 분석하여 토큰 단위로 인덱싱**
- InnoDB에서도 전문 검색 인덱스 지원

### **8.5.2 전문 검색 처리 흐름**

전문 검색 인덱스 생성 과정

1. 문서 분석
2. 토큰 분리
3. 불용어 제거
4. 인덱스 저장

### **8.5.3 어근 분석 알고리즘**

- 단어의 **원형(어근)** 을 기준으로 인덱싱
- 언어 의존적
- MySQL은 MeCab 플러그인 지원

특징

- 형태소 분석 기반
- 정확도 높음
- 설정 및 관리 난이도 높음

### **8.5.4 n-gram 알고리즘**

- 텍스트를 **n글자 단위로 분리**
- 언어 독립적
- MySQL 기본 전문 검색 방식

일반적으로

- 2-gram(bi-gram) 사용

예

- “question” → qu ue es st ti io on

### **8.5.5 불용어 처리**

불용어

- 검색 의미가 없는 단어
- 기본 제공 불용어 존재

관리 방법

- 서버 내장 불용어 사용
- 사용자 정의 불용어 파일 사용
- 불용어 처리 완전 비활성화 가능

주의

- 설정 변경 후 기존 인덱스에는 반영되지 않음
- 반드시 인덱스 재생성 필요

### **8.5.6 전문 검색 인덱스 사용 조건**

- MATCH(…) AGAINST(…) 문법 사용
- 전문 검색 인덱스가 생성된 컬럼만 대상
- LIKE 검색은 전문 검색 인덱스를 사용하지 않음

## **8.6 함수 기반 인덱스**

### **8.6.1 개요**

컬럼 값 그대로가 아닌 **계산 결과에 대해 인덱스를 생성**

MySQL 8.0부터 본격 지원

구현 방식

- 가상 컬럼 기반 인덱스
- 함수 직접 사용 인덱스

### **8.6.2 가상 컬럼 기반 인덱스**

- 가상 컬럼을 추가
- 해당 컬럼에 인덱스 생성

특징

- 테이블 구조 변경 필요
- 내부적으로 B-Tree 인덱스와 동일

### **8.6.3 함수 직접 사용 인덱스**

- 테이블 구조 변경 없음
- 함수 결과에 직접 인덱스 생성

주의

- WHERE 조건의 함수 표현식이
    - 인덱스 생성 시 표현식과 **완전히 동일**해야 사용 가능

## **8.7 멀티 밸류 인덱스**

### **8.7.1 개념**

- 하나의 레코드가 **여러 개의 인덱스 키**를 가질 수 있음
- JSON 배열 요소에 대해 인덱싱 가능

MySQL 8.0에서 본격 지원

### **8.7.2 활용 예**

- JSON 배열 내부 값 검색
- MEMBER OF
- JSON_CONTAINS
- JSON_OVERLAPS

일반 조건 비교로는 사용 불가

## **8.8 클러스터링 인덱스**

### **8.8.1 개념**

- InnoDB 테이블은 **프라이머리 키 기준으로 정렬 저장**
- 프라이머리 키 자체가 **클러스터링 인덱스**
- 테이블 = 하나의 거대한 인덱스

<img width="502" height="438" alt="image" src="https://github.com/user-attachments/assets/029cfd77-b493-4787-a03d-258f5f81f2cc" />

### **8.8.2 프라이머리 키 변경의 영향**

- 프라이머리 키 변경 시 레코드의 물리적 위치 변경
- UPDATE 비용 큼

<img width="487" height="431" alt="image" src="https://github.com/user-attachments/assets/b31b95d3-1b57-431b-b841-0b003ec7c800" />

### **8.8.3 프라이머리 키 선택 기준**

우선순위

1. 명시적 프라이머리 키
2. NOT NULL 유니크 인덱스
3. 내부 자동 증가 컬럼

권장 사항

- 반드시 프라이머리 키 명시
- 가능하면 AUTO_INCREMENT 사용

### **8.8.4 세컨더리 인덱스와의 관계**

InnoDB 세컨더리 인덱스

- 레코드 주소 저장하지 않음
- **프라이머리 키 값 저장**

검색 과정

1. 세컨더리 인덱스 탐색
2. 프라이머리 키로 클러스터링 인덱스 재탐색

### **8.8.5 장단점 요약**

장점

- 프라이머리 키 기반 조회 매우 빠름
- 범위 검색 효율적

단점

- INSERT, UPDATE, DELETE 비용 증가
- 프라이머리 키 크기가 크면 모든 인덱스 영향

## **8.9 유니크 인덱스**

### **8.9.1 개념**

- 중복 값 방지 제약
- 인덱스이면서 제약 조건

특징

- NULL 허용 가능
- 프라이머리 키와는 목적이 다름

### **8.9.2 일반 세컨더리 인덱스와 비교**

읽기 성능

- 거의 차이 없음

쓰기 성능

- 유니크 인덱스는
    - 중복 검사 필요
    - 쓰기 비용 증가

### **8.9.3 사용 시 주의사항**

- 성능 향상 목적만으로 유니크 인덱스 생성 금지
- 이미 유니크 인덱스가 있다면 동일 컬럼에 일반 인덱스 중복 생성 불필요

## **8.10 외래키**

### **8.10.1 외래키 기본 동작**

- InnoDB에서만 지원
- 외래키 생성 시
    - 자동으로 인덱스 생성

### **8.10.2 잠금과 대기**

외래키 특징

- 부모 테이블 변경 시
    - 자식 테이블에 잠금 전파 가능
- 자식 테이블 변경 시
    - 부모 테이블 확인 필요

### **8.10.3 주의사항**

- 외래키는 무조건 좋은 선택이 아님
- 트랜잭션 충돌 가능성 증가
- 고부하 환경에서는 신중히 사용
