# 08. 인덱스

이 장에서는 MySQL에서 사용하는 인덱스의 구조와 동작 방식을 중심으로 **디스크 I/O, B-Tree 인덱스의 특성, 그리고 인덱스를 통해 데이터를 읽는 방식**을 설명한다.

인덱스는 단순한 성능 최적화 수단이 아니라 **쿼리 실행 계획과 스토리지 접근 방식을 결정하는 핵심 요소**다.

## **8.1 디스크 읽기 방식**

인덱스는 결국 **디스크에서 읽는 양을 줄이기 위한 구조**다.

그래서 인덱스를 이해하려면 먼저 디스크 I/O 특성을 이해해야 한다.

### **8.1.1 HDD와 SSD**

- CPU와 메모리는 매우 빠르다.
- 디스크는 상대적으로 매우 느리다.
- DB 서버 성능 병목은 대부분 디스크 I/O에서 발생한다.
- SSD는 HDD보다 랜덤 I/O 성능이 크게 개선되었다.
- 그래도 메모리와 비교하면 디스크는 여전히 느리다.

결론적으로 DB 성능 튜닝의 핵심은 디스크 접근을 최소화하는 것이다.

### **8.1.2 랜덤 I/O와 순차 I/O**

<img width="293" height="296" alt="image" src="https://github.com/user-attachments/assets/d5c68df2-05a6-420d-af69-3ec08dc08b98" />

- **순차 I/O**
    - 연속된 위치의 데이터를 한 번에 읽는다.
    - 디스크 헤드 이동이 적다.
    - 처리 효율이 높다.
- **랜덤 I/O**
    - 매번 다른 위치를 읽는다.
    - 디스크 헤드 이동 비용이 크다.
    - 작은 데이터라도 I/O 호출 횟수가 늘어나면 매우 비싸다.

인덱스 튜닝의 본질은 다음 두 가지다.

- 랜덤 I/O 횟수를 줄인다.
- 꼭 필요한 데이터만 읽는다.

## **8.2 인덱스란**

인덱스는 **정렬된 키와 레코드 위치 정보를 가진 자료 구조**다.

책의 찾아보기와 동일한 개념이다.

### **인덱스의 기본 성질**

- 키 값 기준으로 정렬되어 있다.
- 빠른 검색이 가능하다.
- 대신 쓰기 비용이 증가한다.

즉, 인덱스는 다음을 교환하는 구조다.

- 읽기 성능 향상
- 쓰기 성능과 저장 공간 희생

### **인덱스와 데이터 파일의 차이**

- 데이터 파일은 일반적으로 정렬되지 않는다.
- 인덱스는 항상 키 값 기준으로 정렬된다.
- 정렬 비용을 미리 지불해두고 조회 시 이득을 얻는다.

## **8.3 B-Tree 인덱스**

B-Tree는 MySQL에서 가장 일반적으로 사용되는 인덱스 구조다.

키 값이 정렬된 상태로 유지되는 트리 구조다.

<img width="641" height="491" alt="image" src="https://github.com/user-attachments/assets/341d580e-a4ed-498f-8614-0e9a883bf9b4" />

### **8.3.1 구조와 특성**

B-Tree 인덱스는 다음 노드들로 구성된다.

- 루트 노드
- 브랜치 노드
- 리프 노드

검색은 항상 루트 노드부터 시작해 리프 노드까지 내려간다.

### **8.3.1.1 InnoDB에서의 매우 중요한 특징**

InnoDB에서는 **데이터 파일 자체가 프라이머리 키 인덱스**다.

- 프라이머리 키 인덱스의 리프 노드는 실제 레코드의 모든 컬럼 값을 가진다.
- 즉 프라이머리 키 인덱스 = 데이터 파일이다.

반면 세컨더리 인덱스는 다르다.

- 세컨더리 인덱스의 리프 노드는 세컨더리 인덱스 키 값과 프라이머리 키 값을 가진다.
- 실제 레코드 전체는 포함하지 않는다.

따라서 세컨더리 인덱스를 통해 레코드를 읽을 때는 다음 과정이 필요하다.

- 세컨더리 인덱스 검색
- 프라이머리 키 인덱스 재검색

이 추가 단계가 성능에 영향을 준다.

<img width="558" height="405" alt="image" src="https://github.com/user-attachments/assets/09be6504-a5fe-4e4d-8257-8b90f84016b5" />

<img width="718" height="386" alt="image" src="https://github.com/user-attachments/assets/1a218892-822e-4a34-bdb8-20a40662520b" />

## **8.3.2 B-Tree 인덱스 키 추가와 삭제**

### **인덱스 키 추가**

- INSERT 또는 인덱스 컬럼 UPDATE 시 발생한다.
- B-Tree에서 저장 위치를 찾는다.
- 리프 노드에 공간이 없으면 페이지 분할이 발생한다.
- 페이지 분할은 상위 노드까지 영향을 줄 수 있다.
- 쓰기 비용이 증가한다.

### **인덱스 키 삭제**

- 리프 노드에서 키만 제거한다.
- 공간은 바로 반환되지 않을 수 있다.
- InnoDB에서는 지연 정리가 가능하다.

### **인덱스 키 변경**

- B-Tree 구조상 키 값 자체를 수정할 수 없다.
- 기존 키 삭제 후 새 키 추가로 처리된다.
- 결과적으로 삭제 + 추가 비용이 발생한다.

## **8.3.3 B-Tree 인덱스 키 검색**

인덱스 검색은 다음 특징을 가진다.

- 루트 → 브랜치 → 리프 순으로 탐색한다.
- 동등 비교와 범위 비교에 모두 적합하다.
- 인덱스 키에 변형이 가해지면 사용할 수 없다.
- 함수 연산이나 타입 변환이 있으면 인덱스가 무력화된다.

## **8.3.4 B-Tree 인덱스를 통한 데이터 읽기 방식**

B-Tree 인덱스를 통한 읽기 방식은 크게 네 가지로 나뉜다.

- 인덱스 레인지 스캔
- 인덱스 풀 스캔
- 루스 인덱스 스캔
- 인덱스 스킵 스캔

## **8.3.4.1 인덱스 레인지 스캔**

가장 일반적이고 효율적인 방식이다.

- 동작 과정
    - 인덱스 탐색으로 시작 위치를 찾는다.
    - 이후 리프 노드를 순서대로 스캔한다.
    - 필요한 레코드만 읽는다.

<img width="546" height="433" alt="image" src="https://github.com/user-attachments/assets/f83c5507-9943-45fc-814e-ce3e4ed9ae50" />

- 특징
    - 랜덤 I/O와 순차 I/O가 혼합된다.
    - 범위가 좁을수록 효율이 좋다.
    - 인덱스를 사용하는 대표적인 방식이다.
 
<img width="631" height="442" alt="image" src="https://github.com/user-attachments/assets/863622e2-c04a-4022-84f3-1f7b2ccc4e7f" />

## **8.3.4.2 인덱스 풀 스캔**

- 인덱스의 처음부터 끝까지 모두 읽는다.
- 보통 인덱스 선행 컬럼 조건이 없는 경우 발생한다.
- 테이블 풀 스캔보다는 저렴할 수 있다.
- 그래도 효율적인 방식은 아니다.

<img width="538" height="429" alt="image" src="https://github.com/user-attachments/assets/bb97eeef-130a-4d25-a92c-b418cb1fbff2" />

## **8.3.4.3 루스 인덱스 스캔**

- 필요 없는 인덱스 키는 건너뛰면서 읽는다.
- GROUP BY, MIN, MAX 같은 집계 최적화에 사용된다.
- 모든 인덱스에서 가능한 것은 아니다.
- 제약 조건이 많다.

<img width="465" height="598" alt="image" src="https://github.com/user-attachments/assets/78664d23-dc33-4b95-a4f9-22fd7990b63d" />

## **8.3.4.4 인덱스 스킵 스캔**

MySQL 8.0부터 본격적으로 지원된다.

- 선행 컬럼 조건이 없어도 인덱스를 활용한다.
- 내부적으로 선행 컬럼의 가능한 값들을 순회한다.
- 조회 조건에 없는 선행 컬럼의 유니크한 값의 갯수가 적어야 한다.
- 커버링 인덱스여야 실효성이 높다.

<img width="404" height="419" alt="image" src="https://github.com/user-attachments/assets/108cadc6-2d77-4a4c-8341-591975cb8839" />

## **8.3.5 다중 컬럼 인덱스**

다중 컬럼 인덱스는 **컬럼 순서가 핵심**이다.

- 항상 왼쪽 컬럼부터 정렬된다.
- 왼쪽 컬럼 조건이 없으면 범위 결정에 사용할 수 없다.

<img width="369" height="536" alt="image" src="https://github.com/user-attachments/assets/801325b2-cce3-46fa-8866-5f8cbf3bf358" />

## **8.3.6 B-Tree 인덱스의 정렬과 스캔 방향**

- 인덱스는 생성 시 ASC 또는 DESC로 정렬된다.
- MySQL 8.0부터 컬럼별 혼합 정렬이 가능하다.
- 인덱스는 정방향과 역방향 모두 스캔 가능하다.
- ORDER BY와 LIMIT 최적화에 매우 중요하다.

<img width="424" height="453" alt="image" src="https://github.com/user-attachments/assets/41e6b1f2-a444-4864-9d00-ea8934943ec7" />

<img width="473" height="237" alt="image" src="https://github.com/user-attachments/assets/a66857f3-f006-4297-b740-e305ae23d180" />

## **8.3.7 B-Tree 인덱스의 가용성과 효율성**

### **작업 범위 결정 조건**

- 동등 비교
- 범위 비교
- 좌측 일치 LIKE

### **사용할 수 없는 경우**

- NOT EQUAL
- NOT IN
- NOT BETWEEN
- 함수 적용
- 타입 변환
- 선행 컬럼 조건 누락
